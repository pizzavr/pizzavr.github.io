<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Physics Circles Playground</title>
	<style>
		body { margin: 0; overflow: hidden; }
		canvas { background: #222; display: block; }
		#controls-panel {
			position: absolute;
			top: 0;
			right: 0;
			width: 280px;
			height: 100vh;
			background: rgba(34, 34, 34, 0.9);
			color: #fff;
			font-family: sans-serif;
			padding: 20px;
			box-sizing: border-box;
			transform: translateX(100%);
			transition: transform 0.3s ease-in-out;
			overflow-y: auto;
			z-index: 100;
		}
		#controls-panel.visible {
			transform: translateX(0);
		}
		#toggle-btn {
			position: absolute;
			top: 10px;
			right: 10px;
			background: #333;
			color: #fff;
			border: none;
			border-radius: 4px;
			padding: 8px 12px;
			cursor: pointer;
			z-index: 101;
			font-size: 16px;
		}
		.control-group {
			margin-bottom: 20px;
		}
		.control-group h3 {
			margin-top: 0;
			border-bottom: 1px solid #555;
			padding-bottom: 5px;
		}
		.control-item {
			margin-bottom: 10px;
		}
		.control-item label {
			display: block;
			margin-bottom: 5px;
		}
		button {
			padding: 5px 10px;
			margin: 2px;
			border: none;
			border-radius: 4-px;
			cursor: pointer;
		}
		input[type="range"] {
			vertical-align: middle;
			width: 150px;
		}
		/* Style for custom input */
		.gravity-input-group input[type="number"] {
			width: 50px;
			text-align: right;
			margin-right: 5px;
			vertical-align: middle;
		}
		#info-text {
			position: absolute;
			top: 10px;
			left: 10px;
			color: #fff;
			font-family: sans-serif;
			user-select: none;
		}
		input[type="color"] {
			height: 25px;
			border: none;
			padding: 0;
			margin: 0;
			vertical-align: middle;
		}
		.ball-editor-panel input[type="text"], .ball-editor-panel input[type="number"] {
			width: 100px;
		}
        /* Update Board Specific Styles */
        #update-board {
            margin-top: 30px;
            padding-top: 10px;
            border-top: 1px solid #555;
            font-size: 14px;
        }
        #update-board h3 {
            border-bottom: none;
        }
        #update-board ul {
            list-style: none;
            padding-left: 0;
            margin: 5px 0 15px 0;
        }
        #update-board li {
            margin-bottom: 5px;
            padding-left: 10px;
            text-indent: -10px;
        }
        #update-board li:before {
            content: "â€¢";
            margin-right: 5px;
            color: #4af;
        }

        /* Help Modal Styles */
        #help-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 200;
            font-family: sans-serif;
        }
        #help-content {
            background: #222;
            color: #fff;
            padding: 30px;
            border-radius: 10px;
            max-width: 400px;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.2);
        }
        #help-content h2 {
            border-bottom: 2px solid #4af;
            padding-bottom: 10px;
            margin-top: 0;
        }
        #help-content p {
            margin: 15px 0;
        }
        #help-content strong {
            color: #4af;
        }
        #help-close-btn {
            float: right;
            background: #c00;
            color: #fff;
            font-weight: bold;
            padding: 8px 12px;
        }
		
		/* New Editor Styles */
		.editor-panel {
			position: absolute;
			background: #333;
			color: #fff;
			padding: 12px;
			border-radius: 8px;
			z-index: 10;
			font-size: 14px;
			box-shadow: 0 4px 8px rgba(0,0,0,0.3);
		}
		.editor-panel label, .editor-panel input, .editor-panel button {
			vertical-align: middle;
			margin: 5px 0;
		}
		.editor-panel input[type="number"], .editor-panel input[type="text"] {
			width: 60px;
			margin-left: 5px;
			background: #222;
			border: 1px solid #555;
			color: #fff;
		}
		.editor-panel input[type="color"] {
			background: none;
			border: none;
		}
		.editor-panel button {
			margin-top: 10px;
		}
		
	</style>
</head>
<body>
	<div id="info-text">
		**Physics Circles Playground**<br>
		Click to add circles.<br>
		Right-click an element to edit its properties.<br>
		Drag balls to move. Double-click to connect.<br>
		Hover over an element and press 'D' to delete it.
	</div>
	<button id="toggle-btn">Controls â–¶</button>
	
	<div id="controls-panel">
		<div class="control-group">
			<h3>Simulation Controls</h3>
			<div class="control-item">
				<button id="pauseBtn">Pause: Off</button>
				<button id="helpBtn">How to Play ðŸ’¡</button>
			</div>
			<div class="control-item">
				<button id="deleteModeBtn">Single-Click Delete: Off</button>
			</div>
			<div class="control-item">
				<button id="wallModeBtn">Wall Mode: Off</button>
			</div>
			<div class="control-item">
				<button id="clearAllBtn">Clear All</button>
			</div>
		</div>

		<div class="control-group">
			<h3>Global Physics</h3>
			<div class="control-item">
				<button id="gravityBtn">Gravity: On</button>
				<div class="gravity-input-group">
					Manual: 
					<input type="number" id="gravityCustomInput" value="50" step="1" min="-200" max="200">
					%
					<button id="applyGravityBtn">Apply</button>
				</div>
				<div>
					Strength (xG): <input type="range" id="gravitySlider" min="-2.0" max="2.0" step="0.01" value="0.5">
					<span id="gravityValue">0.50</span>
				</div>
			</div>
			<div class="control-item">
				<button id="resistanceBtn">Resistance: On</button>
			</div>
		</div>

		<div class="control-group">
			<h3>Boundary Walls</h3>
			<div class="control-item">
				<button id="wallTopBtn">Top Wall: On</button>
				<button id="wallBottomBtn">Bottom Wall: On</button>
			</div>
			<div class="control-item">
				<button id="wallLeftBtn">Left Wall: On</button>
				<button id="wallRightBtn">Right Wall: On</button>
			</div>
		</div>

		<div class="control-group">
			<h3>Display Options</h3>
			<div class="control-item">
				<button id="velocityBtn">Show Velocity: Off</button>
			</div>
			<div class="control-item">
				<button id="massLabelBtn">Show Mass: On</button>
			</div>
		</div>
        
        <div id="update-board" class="control-group">
            <h3>Update Board (v6.2)</h3>
            
            <p>Recent Additions:</p>
            <ul>
				<li>**v6.2:** Added a **Wall Editor** to change wall color, friction, and restitution.</li>
				<li>**v6.1:** **FIX:** Corrected issue where dragging a ball would incorrectly create a new ball.</li>
				<li>**v6.0:** Added **"How to Play"** help modal for quick reference.</li>
                <li>**v5.0:** Added a **Custom Walls** creation tool.</li>
            </ul>
        </div>
        </div>

	<canvas id="canvas"></canvas>

    <div id="help-modal">
        <div id="help-content">
            <button id="help-close-btn">Close X</button>
            <h2>How to Play ðŸ’¡</h2>
            
            <h3>On the Canvas (Mouse)</h3>
            <ul>
                <li>**Left Click:** Add a new circle (ball).</li>
                <li>**Drag:** Grab a ball to move it. Fling it to apply velocity.</li>
                <li>**Right Click (on an element):** Open the **Editor** to change its properties.</li>
                <li>**Double Click (on a ball):** Start **Connect Mode** (the ball glows yellow). Click a second ball to draw a spring between them.</li>
            </ul>

            <h3>Special Modes & Keys</h3>
            <ul>
                <li>**Wall Mode (Control Panel):** Click and drag on the canvas to draw a permanent wall segment.</li>
                <li>**Press 'D':** Hover over a ball, spring, or wall and press **'D'** to delete it instantly.</li>
                <li>**Single-Click Delete Mode:** Turn this on in the panel to delete elements with a single left click.</li>
            </ul>

            <h3>Controls Panel</h3>
            <p>Use the panel to customize **Global Gravity**, toggle **Resistance/Air Friction**, turn the **Boundary Walls** (edges of the screen) on or off, and pause the simulation.</p>
        </div>
    </div>
    <script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const BASE_GRAVITY_UNIT = 0.5; // Represents 100% or 1G. 
let GRAVITY = BASE_GRAVITY_UNIT; // Current Gravity Multiplier
let gravityOn = true;
let showVelocity = false;
let FRICTION = 0.99;
let resistanceOn = true;
const RADIUS = 20; 
const SPRING_STRENGTH = 0.01; 
const SPRING_LENGTH = 100;
const WALL_THICKNESS = 5;

// Wall control state
let wallTopOn = true;
let wallBottomOn = true;
let wallLeftOn = true;
let wallRightOn = true;


let circles = [];
let springs = [];
let walls = [];
let draggingBall = null;
let dragOffset = {x:0, y:0};
let dragHistory = []; 
let selectedBall = null;
let connectMode = false;
let selectedSpring = null;
let deleteMode = false; 
let showMassLabel = true;
let paused = false;
let hoveredElement = null;
let wallMode = false;
let currentDrawingWall = null;


// ====================================================================
// --- Utility Functions (Hover and Delete) ---
// ====================================================================

function getHoveredElement(x, y) {
	let foundBall = circles.find(c => Math.hypot(c.x-x, c.y-y) < c.radius);
	if (foundBall) return foundBall;

	let foundSpring = springs.find(s => {
		let ax = s.a.x, ay = s.a.y, bx = s.b.x, by = s.b.y;
		let dx = bx - ax, dy = by - ay;
		let t = ((x-ax)*dx + (y-ay)*dy) / (dx*dx + dy*dy);
		t = Math.max(0, Math.min(1, t));
		let px = ax + t*dx, py = ay + t*dy;
		return Math.hypot(px-x, py-y) < 10;
	});
	if (foundSpring) return foundSpring;

	let foundWall = walls.find(w => {
		const { x1, y1, x2, y2 } = w;
		const dx = x2 - x1;
		const dy = y2 - y1;
		const wallLengthSq = dx * dx + dy * dy;
		
		const t = ((x - x1) * dx + (y - y1) * dy) / (wallLengthSq || 1); // Avoid division by zero
		const closestT = Math.max(0, Math.min(1, t));
		const closestX = x1 + closestT * dx;
		const closestY = y1 + closestT * dy;
		return Math.hypot(x - closestX, y - closestY) < WALL_THICKNESS + 5;
	});
	if (foundWall) return foundWall;

	return null;
}

function deleteElement(element) {
	if (element instanceof Circle) {
		springs = springs.filter(s => s.a !== element && s.b !== element);
		circles = circles.filter(c => c !== element);
		if (selectedBall === element) selectedBall = null;
		if (draggingBall === element) draggingBall = null;
	} else if (element instanceof Spring) {
		springs = springs.filter(s => s !== element);
		if (selectedSpring === element) selectedSpring = null;
	} else if (element instanceof Wall) {
		walls = walls.filter(w => w !== element);
	}
	// Close any open editors for the deleted element
	if (window.ballEditor) window.ballEditor.remove();
	if (window.springEditor) window.springEditor.remove();
	if (window.wallEditor) window.wallEditor.remove();
	if (hoveredElement === element) hoveredElement = null;
}


// ====================================================================
// --- Class Definitions ---
// ====================================================================

class Circle {
	constructor(x, y) {
		this.x = x;
		this.y = y;
		this.vx = 0;
		this.vy = 0;
		this.mass = 1; 
		this.isDragged = false;
		this.locked = false; 
		this.tx = x; 
		this.ty = y;
		this.color = '#4af'; 
		this.label = ''; 
	}
	get radius() {
		return RADIUS + (this.mass - 1) * 8;
	}
	draw() {
		ctx.beginPath();
		ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
		
		let fillStyle = (selectedBall === this) ? '#ff0' : (this.locked ? '#888' : this.color);
		
		if (hoveredElement === this) {
			ctx.shadowBlur = 15;
			ctx.shadowColor = 'red';
		}
		
		ctx.fillStyle = fillStyle;
		ctx.fill();
		ctx.shadowBlur = 0;
		ctx.strokeStyle = '#fff';
		ctx.lineWidth = 2;
		ctx.stroke();
		
		// 1. Draw Custom Label (Name)
		if (this.label) {
			ctx.font = '14px sans-serif';
			ctx.fillStyle = '#fff';
			ctx.textAlign = 'center';
			ctx.fillText(this.label, this.x, this.y - this.radius - (showMassLabel ? 25 : 10)); 
		}

		// 2. Draw Mass Label
		if (showMassLabel) {
			ctx.font = '12px sans-serif';
			ctx.fillStyle = '#fff';
			ctx.textAlign = 'center';
			ctx.fillText('m=' + this.mass.toFixed(2), this.x, this.y - this.radius - 10);
		}
		
		
		if (showVelocity) {
			let speed = Math.hypot(this.vx, this.vy);
			ctx.font = '14px sans-serif';
			ctx.fillStyle = '#0ff'; 
			ctx.textAlign = 'left';
			ctx.fillText('v=' + speed.toFixed(2), this.x + this.radius + 8, this.y + 5);
		}
	}
	update() {
		if (this.locked) {
			this.vx = 0;
			this.vy = 0;
			return;
		}

		if (this.isDragged) {
			this.vx = (this.x - this.tx); 
			this.vy = (this.y - this.ty);
			this.tx = this.x;
			this.ty = this.y;
			return;
		}

		this.tx = this.x;
		this.ty = this.y;
		
		// Gravity force applied, scaled by mass. Negative gravity works here too.
		if (gravityOn) {
			this.vy += GRAVITY * this.mass; 
		}

		
		if (resistanceOn) {
			this.vx *= FRICTION;
			this.vy *= FRICTION;
		}
		this.x += this.vx;
		this.y += this.vy;
		
		const restitution = 0.7;

		// --- Boundary Collision Logic ---
		
		// Left Wall
		if (wallLeftOn && this.x < this.radius) { 
			this.x = this.radius; 
			this.vx *= -restitution; 
		}
		// Right Wall
		if (wallRightOn && this.x > canvas.width - this.radius) { 
			this.x = canvas.width - this.radius; 
			this.vx *= -restitution; 
		}
		// Top Wall
		if (wallTopOn && this.y < this.radius) { 
			this.y = this.radius; 
			this.vy *= -restitution; 
		}
		// Bottom Wall
		if (wallBottomOn && this.y > canvas.height - this.radius) { 
			this.y = canvas.height - this.radius; 
			this.vy *= -restitution; 
		}
	}
}

class Spring {
	constructor(a, b) {
		this.a = a;
		this.b = b;
		this.length = SPRING_LENGTH;
		this.strength = SPRING_STRENGTH;
		this.selected = false;
	}
	draw() {
		ctx.beginPath();
		ctx.moveTo(this.a.x, this.a.y);
		ctx.lineTo(this.b.x, this.b.y);
		
		let strokeStyle = this.selected ? '#0f0' : '#fa4';
		let lineWidth = this.selected ? 5 : 3;
		
		if (hoveredElement === this) {
			strokeStyle = 'red';
			lineWidth = 5;
		}

		ctx.strokeStyle = strokeStyle;
		ctx.lineWidth = lineWidth;
		ctx.stroke();
	}
	update() {
		let dx = this.b.x - this.a.x;
		let dy = this.b.y - this.a.y;
		let dist = Math.hypot(dx, dy);
		let force = (dist - this.length) * this.strength; 
		let fx = (dx / dist) * force;
		let fy = (dy / dist) * force;
		
		// Divide the spring force by the ball's mass (F = ma, so a = F/m).
		if (!this.a.locked) {
			this.a.vx += fx / this.a.mass; 
			this.a.vy += fy / this.a.mass;
		}
		if (!this.b.locked) {
			this.b.vx -= fx / this.b.mass; 
			this.b.vy -= fy / this.b.mass;
		}
	}
}

class Wall {
	constructor(x1, y1, x2, y2) {
		this.x1 = x1;
		this.y1 = y1;
		this.x2 = x2;
		this.y2 = y2;
		this.color = '#fff';
		this.restitution = 0.8; // Bounciness (0 = no bounce, 1 = perfect bounce)
		this.friction = 0.95; // Stickiness (0 = no friction, 1 = perfectly sticky)
	}
	draw() {
		ctx.beginPath();
		ctx.moveTo(this.x1, this.y1);
		ctx.lineTo(this.x2, this.y2);
		ctx.strokeStyle = this.color;
		ctx.lineWidth = WALL_THICKNESS;
		if (hoveredElement === this) {
			ctx.shadowBlur = 15;
			ctx.shadowColor = 'red';
		}
		ctx.stroke();
		ctx.shadowBlur = 0;
	}
}


// ====================================================================
// --- Core Simulation Loop ---
// ====================================================================

function draw() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	for (let spring of springs) spring.draw();
	for (let wall of walls) wall.draw();
	for (let circle of circles) circle.draw();

	if (currentDrawingWall) {
		ctx.beginPath();
		ctx.moveTo(currentDrawingWall.x1, currentDrawingWall.y1);
		ctx.lineTo(currentDrawingWall.x2, currentDrawingWall.y2);
		ctx.strokeStyle = currentDrawingWall.color;
		ctx.lineWidth = WALL_THICKNESS;
		ctx.setLineDash([10, 5]);
		ctx.stroke();
		ctx.setLineDash([]);
	}
	
	if (showVelocity) {
		for (let circle of circles) {
			let vx = circle.vx, vy = circle.vy;
			let speed = Math.hypot(vx, vy);
			if (speed > 0.5) {
				let arrowLen = Math.min(40, speed*8);
				let angle = Math.atan2(vy, vx);
				let x1 = circle.x, y1 = circle.y;
				let x2 = x1 + Math.cos(angle)*arrowLen;
				let y2 = y1 + Math.sin(angle)*arrowLen;
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.strokeStyle = '#0ff';
				ctx.lineWidth = 2;
				ctx.stroke();
			}
		}
	}

	if (connectMode && selectedBall) {
		ctx.beginPath();
		ctx.arc(selectedBall.x, selectedBall.y, selectedBall.radius+6, 0, Math.PI*2);
		ctx.strokeStyle = '#ff0';
		ctx.setLineDash([5,5]);
		ctx.stroke();
		ctx.setLineDash([]);
	}
}

function update() {
	if (paused) return;
	
	for (let spring of springs) spring.update();
	for (let circle of circles) circle.update();
	
	// Circle-Circle Collision
	for (let i = 0; i < circles.length; i++) {
		for (let j = i+1; j < circles.length; j++) {
			let a = circles[i], b = circles[j];
			
			const aIsLocked = a.locked;
			const bIsLocked = b.locked;
			if (aIsLocked && bIsLocked) continue;

			let dx = b.x - a.x, dy = b.y - a.y;
			let dist = Math.hypot(dx, dy);
			let minDist = a.radius + b.radius;
			
			if (dist < minDist) {
				let angle = Math.atan2(dy, dx);
				let overlap = minDist - dist;
				
				if (aIsLocked) {
					b.x += Math.cos(angle) * overlap;
					b.y += Math.sin(angle) * overlap;
				} else if (bIsLocked) {
					a.x -= Math.cos(angle) * overlap;
					a.y -= Math.sin(angle) * overlap;
				} else {
					let totalMass = a.mass + b.mass;
					let ratioA = b.mass / totalMass;
					let ratioB = a.mass / totalMass;
					
					a.x -= Math.cos(angle) * overlap * ratioA;
					a.y -= Math.sin(angle) * overlap * ratioA;
					b.x += Math.cos(angle) * overlap * ratioB;
					b.y += Math.sin(angle) * overlap * ratioB;
				}
				
				let v1 = a.vx * Math.cos(angle) + a.vy * Math.sin(angle);
				let v2 = b.vx * Math.cos(angle) + b.vy * Math.sin(angle);
				
				let m1 = aIsLocked ? 99999999 : a.mass; 
				let m2 = bIsLocked ? 99999999 : b.mass;
				let totalMomentumMass = m1 + m2;
				
				let v1f = (v1 * (m1 - m2) + 2 * m2 * v2) / totalMomentumMass;
				let v2f = (v2 * (m2 - m1) + 2 * m1 * v1) / totalMomentumMass;
				
				let dv1 = v1f - v1;
				let dv2 = v2f - v2;
				
				if (!aIsLocked) {
					a.vx += dv1 * Math.cos(angle);
					a.vy += dv1 * Math.sin(angle);
					a.vx *= 0.95; a.vy *= 0.95;
				}
				if (!bIsLocked) {
					b.vx += dv2 * Math.cos(angle);
					b.vy += dv2 * Math.sin(angle);
					b.vx *= 0.95; b.vy *= 0.95;
				}
			}
		}
	}

	// Circle-Wall Collision
	for (let circle of circles) {
		for (let wall of walls) {
			const { x1, y1, x2, y2 } = wall;
			const dx = x2 - x1;
			const dy = y2 - y1;
			const wallLengthSq = dx * dx + dy * dy;
			
			let t = 0;
			if (wallLengthSq !== 0) {
				t = ((circle.x - x1) * dx + (circle.y - y1) * dy) / wallLengthSq;
				t = Math.max(0, Math.min(1, t));
			}

			const closestX = x1 + t * dx;
			const closestY = y1 + t * dy;

			const distSq = Math.pow(circle.x - closestX, 2) + Math.pow(circle.y - closestY, 2);
			const radiusSq = Math.pow(circle.radius, 2);

			if (distSq < radiusSq) {
				const dist = Math.sqrt(distSq);
				const overlap = circle.radius - dist;
				const nx = (circle.x - closestX) / dist;
				const ny = (circle.y - closestY) / dist;
				
				if (!circle.locked) {
					circle.x += nx * overlap;
					circle.y += ny * overlap;
				}

				const dotProduct = circle.vx * nx + circle.vy * ny;
				const tangentVx = circle.vx - dotProduct * nx;
				const tangentVy = circle.vy - dotProduct * ny;
				
				// Apply friction to the tangent velocity component
				const newTangentVx = tangentVx * wall.friction;
				const newTangentVy = tangentVy * wall.friction;

				// Reflect the normal velocity component with restitution
				const newNormalVx = (circle.vx - tangentVx) * -wall.restitution;
				const newNormalVy = (circle.vy - tangentVy) * -wall.restitution;
				
				// Combine and update velocities
				circle.vx = newNormalVx + newTangentVx;
				circle.vy = newNormalVy + newTangentVy;
			}
		}
	}
}

function loop() {
	update();
	draw();
	requestAnimationFrame(loop);
}


// ====================================================================
// --- UI / Event Handlers ---
// ====================================================================

// --- Control Panel Visibility ---
const controlsPanel = document.getElementById('controls-panel');
const toggleBtn = document.getElementById('toggle-btn');
toggleBtn.addEventListener('click', () => {
	controlsPanel.classList.toggle('visible');
	toggleBtn.textContent = controlsPanel.classList.contains('visible') ? 'Controls â—€' : 'Controls â–¶';
});

// --- Help Modal Logic ---
const helpModal = document.getElementById('help-modal');
document.getElementById('helpBtn').onclick = () => { helpModal.style.display = 'flex'; };
document.getElementById('help-close-btn').onclick = () => { helpModal.style.display = 'none'; };
helpModal.addEventListener('click', (e) => {
    if (e.target === helpModal) {
        helpModal.style.display = 'none';
    }
});
// Also close help on ESC key
document.addEventListener('keydown', (e) => {
    if (e.key === 'Escape') {
        helpModal.style.display = 'none';
    }
});


// Wall Toggle Handler Factory
function createWallToggle(wallVarName, buttonId) {
	const btn = document.getElementById(buttonId);
	
	btn.onclick = function() {
		// Toggle the corresponding global variable
		eval(`${wallVarName} = !${wallVarName};`);
		// Update button text and style
		this.textContent = `${buttonId.replace('wall', '').replace('Btn', ' Wall')}: ${eval(wallVarName) ? 'On' : 'Off'}`;
		this.style.background = eval(wallVarName) ? '' : '#888';
	};
}

createWallToggle('wallTopOn', 'wallTopBtn');
createWallToggle('wallBottomOn', 'wallBottomBtn');
createWallToggle('wallLeftOn', 'wallLeftBtn');
createWallToggle('wallRightOn', 'wallRightBtn');

// Gravity Input Logic
const gravitySlider = document.getElementById('gravitySlider');
const gravityValueSpan = document.getElementById('gravityValue');
const gravityCustomInput = document.getElementById('gravityCustomInput');
const applyGravityBtn = document.getElementById('applyGravityBtn');

// Function to sync all gravity controls
function updateGravity(newGravityValue) {
    // Round to 2 decimal places for display consistency
    GRAVITY = Math.round(newGravityValue * 100) / 100;
    
    // Update Slider
    gravitySlider.value = GRAVITY;
    
    // Update Value Span (xG)
    gravityValueSpan.textContent = GRAVITY.toFixed(2);
    
    // Update Custom Input (Percentage)
    const percentage = Math.round((GRAVITY / BASE_GRAVITY_UNIT) * 100);
    gravityCustomInput.value = percentage;
}

// 1. Slider input event (instant update)
gravitySlider.oninput = function() {
    updateGravity(parseFloat(this.value));
};

// 2. Custom Input button click event
applyGravityBtn.onclick = function() {
    let percentage = parseFloat(gravityCustomInput.value);
    
    // Clamp the percentage input to a reasonable range 
    if (isNaN(percentage)) percentage = 0;
    percentage = Math.max(-200, Math.min(200, percentage));
    
    // Calculate new GRAVITY value
    const newGravity = BASE_GRAVITY_UNIT * (percentage / 100);
    
    updateGravity(newGravity);
};

// 3. Custom Input 'Enter' key press (for convenience)
gravityCustomInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        applyGravityBtn.click();
    }
});


// Wall Mode Toggle
const wallModeBtn = document.getElementById('wallModeBtn');
wallModeBtn.onclick = function() {
	wallMode = !wallMode;
	this.textContent = 'Wall Mode: ' + (wallMode ? 'On' : 'Off');
	this.style.background = wallMode ? '#0f0' : '';
};


// Clear All button
document.getElementById('clearAllBtn').onclick = function() {
	circles = [];
	springs = [];
	walls = [];
	draggingBall = null;
	selectedBall = null;
	connectMode = false;
	selectedSpring = null;
	if (window.ballEditor) window.ballEditor.remove();
	if (window.springEditor) window.springEditor.remove();
	if (window.wallEditor) window.wallEditor.remove();
	hoveredElement = null;
};

// Other Button logic
document.getElementById('gravityBtn').onclick = function() {
	gravityOn = !gravityOn;
	this.textContent = 'Gravity: ' + (gravityOn ? 'On' : 'Off');
	this.style.background = gravityOn ? '' : '#888';
};
document.getElementById('velocityBtn').onclick = function() {
	showVelocity = !showVelocity;
	this.textContent = 'Show Velocity: ' + (showVelocity ? 'On' : 'Off');
	this.style.background = showVelocity ? '#0ff' : '';
};
document.getElementById('pauseBtn').onclick = function() {
	paused = !paused;
	this.textContent = 'Pause: ' + (paused ? 'On' : 'Off');
	this.style.background = paused ? '#c00' : '';
};
document.getElementById('deleteModeBtn').onclick = function() {
	deleteMode = !deleteMode;
	this.textContent = 'Single-Click Delete: ' + (deleteMode ? 'On' : 'Off');
	this.style.background = deleteMode ? '#c00' : '';
};
document.getElementById('massLabelBtn').onclick = function() {
	showMassLabel = !showMassLabel;
	this.textContent = 'Show Mass: ' + (showMassLabel ? 'On' : 'Off');
	this.style.background = showMassLabel ? '' : '#888';
};
document.getElementById('resistanceBtn').onclick = function() {
	resistanceOn = !resistanceOn;
	this.textContent = 'Resistance: ' + (resistanceOn ? 'On' : 'Off');
	this.style.background = resistanceOn ? '' : '#888';
	FRICTION = resistanceOn ? 0.99 : 1.0;
};


// Ball property editor
function showBallEditor(ball) {
	if (window.ballEditor) window.ballEditor.remove();
	if (window.springEditor) window.springEditor.remove();
	if (window.wallEditor) window.wallEditor.remove();
	let editor = document.createElement('div');
	window.ballEditor = editor;
	editor.className = 'editor-panel ball-editor-panel';
	editor.innerHTML = `<b>Edit Ball</b><br>
		<label>Name:</label> <input type='text' id='ballLabel' value='${ball.label}'><br>
		<label>Mass:</label> <input type='number' id='ballMass' value='${ball.mass.toFixed(2)}' step='0.1' min='0.1' max='10'><br>
		<label>Color:</label> <input type='color' id='ballColor' value='${ball.color}'><br>
		<label><input type='checkbox' id='ballLock' ${ball.locked ? 'checked' : ''}> Lock Ball</label><br>
		<button id='ballClose'>Close</button>
	`;
	document.body.appendChild(editor);
	
	function updatePanelPosition() {
		editor.style.left = (ball.x - 20) + 'px';
		editor.style.top = (ball.y - ball.radius - 120) + 'px'; 
	}
	updatePanelPosition();
	
	function followBall() {
		if (window.ballEditor === editor) {
			updatePanelPosition();
			requestAnimationFrame(followBall);
		}
	}
	followBall();
	
	// --- Instant Update Logic ---
	const massInput = document.getElementById('ballMass');
	const colorInput = document.getElementById('ballColor');
	const labelInput = document.getElementById('ballLabel');
	const lockInput = document.getElementById('ballLock');

	massInput.oninput = () => {
		ball.mass = Math.max(0.1, parseFloat(massInput.value));
	};
	colorInput.oninput = () => {
		ball.color = colorInput.value;
	};
	labelInput.oninput = () => {
		ball.label = labelInput.value;
	};
	lockInput.oninput = () => {
		ball.locked = lockInput.checked;
	};
	
	document.getElementById('ballClose').onclick = () => {
		editor.remove();
		window.ballEditor = null;
	};
}

// Spring property editor
function showSpringEditor(spring) {
	if (window.ballEditor) window.ballEditor.remove();
	if (window.springEditor) window.springEditor.remove();
	if (window.wallEditor) window.wallEditor.remove();
	let editor = document.createElement('div');
	window.springEditor = editor;
	editor.className = 'editor-panel spring-editor-panel';
	editor.style.left = '50px';
	editor.style.top = '50px';
	editor.innerHTML = `<b>Edit Spring</b><br>
		Length: <input type='number' id='springLength' value='${spring.length}' step='1' min='10' max='1000'><br>
		Strength: <input type='number' id='springStrength' value='${spring.strength}' step='0.001' min='0.001' max='1'><br>
		<button id='springSave'>Save</button>
		<button id='springClose'>Close</button>
	`;
	document.body.appendChild(editor);
	document.getElementById('springSave').onclick = () => {
		spring.length = parseFloat(document.getElementById('springLength').value);
		spring.strength = parseFloat(document.getElementById('springStrength').value);
		spring.selected = false;
		selectedSpring = null;
		editor.remove();
		window.springEditor = null;
	};
	document.getElementById('springClose').onclick = () => {
		spring.selected = false;
		selectedSpring = null;
		editor.remove();
		window.springEditor = null;
	};
}

// Wall property editor
function showWallEditor(wall) {
	if (window.ballEditor) window.ballEditor.remove();
	if (window.springEditor) window.springEditor.remove();
	if (window.wallEditor) window.wallEditor.remove();
	let editor = document.createElement('div');
	window.wallEditor = editor;
	editor.className = 'editor-panel wall-editor-panel';
	editor.style.left = '50px';
	editor.style.top = '50px';
	editor.innerHTML = `<b>Edit Wall</b><br>
		Color: <input type='color' id='wallColor' value='${wall.color}'><br>
		Restitution: <input type='number' id='wallRestitution' value='${wall.restitution}' step='0.01' min='0' max='1'><br>
		Friction: <input type='number' id='wallFriction' value='${wall.friction}' step='0.01' min='0' max='1'><br>
		<button id='wallClose'>Close</button>
	`;
	document.body.appendChild(editor);
	
	const colorInput = document.getElementById('wallColor');
	const restitutionInput = document.getElementById('wallRestitution');
	const frictionInput = document.getElementById('wallFriction');

	colorInput.oninput = () => {
		wall.color = colorInput.value;
	};
	restitutionInput.oninput = () => {
		wall.restitution = Math.max(0, Math.min(1, parseFloat(restitutionInput.value)));
	};
	frictionInput.oninput = () => {
		wall.friction = Math.max(0, Math.min(1, parseFloat(frictionInput.value)));
	};
	
	document.getElementById('wallClose').onclick = () => {
		editor.remove();
		window.wallEditor = null;
	};
}


// Canvas Mouse Events
canvas.addEventListener('mousedown', e => {
	const x = e.clientX, y = e.clientY;
	dragHistory = [];
	let found = getHoveredElement(x, y);

	// Right-click to edit any element
	if (e.button === 2) {
		if (found instanceof Circle) {
			showBallEditor(found);
			return;
		}
		if (found instanceof Spring) {
			showSpringEditor(found);
			return;
		}
		if (found instanceof Wall) {
			showWallEditor(found);
			return;
		}
	}

	// 1. Handle Wall Mode Creation
	if (wallMode) {
		currentDrawingWall = new Wall(x, y, x, y);
		return;
	}

	// 2. Handle Delete Mode
	if (deleteMode && found) {
		deleteElement(found);
		return;
	}

	// 3. Handle Spring Selection
	if (found instanceof Spring) {
		springs.forEach(s => s.selected = false);
		found.selected = true;
		selectedSpring = found;
		showSpringEditor(found);
		return;
	}
	
	// 4. Handle Ball Interaction (Drag, Edit, Connect)
	if (found instanceof Circle) {
		// Connect Mode (Double click has already set connectMode=true, now clicking the second ball)
		if (connectMode) {
			if (selectedBall && found !== selectedBall) {
				if (!springs.some(s => (s.a === selectedBall && s.b === found) || (s.a === found && s.b === selectedBall))) {
					springs.push(new Spring(selectedBall, found));
				}
				connectMode = false;
				selectedBall = null;
				return;
			}
			return;
		}
		
		// Left-Click to Drag
		draggingBall = found;
		dragOffset.x = x - found.x;
		dragOffset.y = y - found.y;
		found.isDragged = true;
		found.tx = found.x; 
		found.ty = found.y;
		selectedBall = found;
		if (window.ballEditor) window.ballEditor.remove(); 
	} 
	// 5. Default: Create New Ball
	else {
		circles.push(new Circle(x, y));
		selectedBall = null;
		connectMode = false;
		if (window.ballEditor) window.ballEditor.remove();
		if (window.springEditor) window.springEditor.remove();
		if (window.wallEditor) window.wallEditor.remove();
	}
});

canvas.addEventListener('contextmenu', e => {
	e.preventDefault();
});

canvas.addEventListener('mousemove', e => {
	const x = e.clientX, y = e.clientY;
	hoveredElement = getHoveredElement(x, y);

	if (wallMode && currentDrawingWall) {
		currentDrawingWall.x2 = x;
		currentDrawingWall.y2 = y;
		return;
	}
	if (draggingBall) {
		let newX = x - dragOffset.x;
		let newY = y - dragOffset.y;
		
		dragHistory.push({x: newX, y: newY, t: performance.now()});
		if (dragHistory.length > 10) dragHistory.shift();

		draggingBall.x = newX;
		draggingBall.y = newY;
	}
});

canvas.addEventListener('mouseup', e => {
	if (wallMode && currentDrawingWall) {
		// Only create a wall if the drag distance is greater than 10 pixels
		if (Math.hypot(currentDrawingWall.x2 - currentDrawingWall.x1, currentDrawingWall.y2 - currentDrawingWall.y1) > 10) {
			walls.push(currentDrawingWall);
		}
		currentDrawingWall = null;
		return;
	}

	if (draggingBall) {
		if (dragHistory.length >= 2) {
			let last = dragHistory[dragHistory.length-1];
			let first = dragHistory[0];
			let dt = (last.t - first.t) / 1000; 
			if (dt > 0) {
				let dx = last.x - first.x;
				let dy = last.y - first.y;
				const flickFactor = 0.05; 
				draggingBall.vx = dx / dt * flickFactor; 
				draggingBall.vy = dy / dt * flickFactor;
			}
		}
		draggingBall.isDragged = false;
		draggingBall = null;
		dragHistory = [];
	}
});

canvas.addEventListener('dblclick', e => {
	if (wallMode) return;
	let x = e.clientX, y = e.clientY;
	let found = circles.find(c => Math.hypot(c.x-x, c.y-y) < c.radius);
	if (found) {
		selectedBall = found;
		connectMode = true;
	}
});

document.addEventListener('keydown', e => {
	if ((e.key === 'd' || e.key === 'D') && 
		document.activeElement.tagName !== 'INPUT' && 
		document.activeElement.tagName !== 'TEXTAREA') 
	{
		if (hoveredElement) {
			e.preventDefault(); 
			deleteElement(hoveredElement);
		}
	}
});


window.addEventListener('resize', () => {
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
});

// Initial call to set gravity state and start the loop
updateGravity(GRAVITY); 
loop();
</script>
</body>
</html>
