<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Physics Circles Playground</title>
	<style>
		body { margin: 0; overflow: hidden; }
		canvas { background: #222; display: block; }
		#controls-panel {
			position: absolute;
			top: 0;
			right: 0;
			width: 280px;
			height: 100vh;
			background: rgba(34, 34, 34, 0.9);
			color: #fff;
			font-family: sans-serif;
			padding: 20px;
			box-sizing: border-box;
			transform: translateX(100%);
			transition: transform 0.3s ease-in-out;
			overflow-y: auto;
			z-index: 100;
		}
		#controls-panel.visible {
			transform: translateX(0);
		}
		#toggle-btn {
			position: absolute;
			top: 10px;
			right: 10px;
			background: #333;
			color: #fff;
			border: none;
			border-radius: 4px;
			padding: 8px 12px;
			cursor: pointer;
			z-index: 101;
			font-size: 16px;
		}
		.control-group {
			margin-bottom: 20px;
		}
		.control-group h3 {
			margin-top: 0;
			border-bottom: 1px solid #555;
			padding-bottom: 5px;
		}
		.control-item {
			margin-bottom: 10px;
		}
		.control-item label {
			display: block;
			margin-bottom: 5px;
		}
		button {
			padding: 5px 10px;
			margin: 2px;
			border: none;
			border-radius: 4px;
			cursor: pointer;
		}
		input[type="range"] {
			vertical-align: middle;
			width: 150px;
		}
		/* Style for custom input */
		.gravity-input-group input[type="number"] {
			width: 50px;
			text-align: right;
			margin-right: 5px;
			vertical-align: middle;
		}
		#info-text {
			position: absolute;
			top: 10px;
			left: 10px;
			color: #fff;
			font-family: sans-serif;
			user-select: none;
		}
		input[type="color"] {
			height: 25px;
			border: none;
			padding: 0;
			margin: 0;
			vertical-align: middle;
		}
		.ball-editor-panel input[type="text"], .ball-editor-panel input[type="number"] {
			width: 100px;
		}
        /* Update Board Specific Styles */
        #update-board {
            margin-top: 30px;
            padding-top: 10px;
            border-top: 1px solid #555;
            font-size: 14px;
        }
        #update-board h3 {
            border-bottom: none;
        }
        #update-board ul {
            list-style: none;
            padding-left: 0;
            margin: 5px 0 15px 0;
        }
        #update-board li {
            margin-bottom: 5px;
            padding-left: 10px;
            text-indent: -10px;
        }
        #update-board li:before {
            content: "•";
            margin-right: 5px;
            color: #4af;
        }
	</style>
</head>
<body>
	<div id="info-text">
		**Physics Circles Playground**<br>
		Click to add circles.<br>
		Right-click a ball to edit its properties instantly.<br>
		Drag balls to move. Double-click to connect.<br>
		Hover over an element and press 'D' to delete it.
	</div>
	<button id="toggle-btn">Controls ▶</button>
	
	<div id="controls-panel">
		<div class="control-group">
			<h3>Simulation Controls</h3>
			<div class="control-item">
				<button id="pauseBtn">Pause: Off</button>
			</div>
			<div class="control-item">
				<button id="deleteModeBtn">Single-Click Delete: Off</button>
			</div>
			<div class="control-item">
				<button id="clearAllBtn">Clear All</button>
			</div>
		</div>

		<div class="control-group">
			<h3>Global Physics</h3>
			<div class="control-item">
				<button id="gravityBtn">Gravity: On</button>
				<div class="gravity-input-group">
					Manual: 
					<input type="number" id="gravityCustomInput" value="50" step="1" min="-200" max="200">
					%
					<button id="applyGravityBtn">Apply</button>
				</div>
				<div>
					Strength (xG): <input type="range" id="gravitySlider" min="-2.0" max="2.0" step="0.01" value="0.5">
					<span id="gravityValue">0.50</span>
				</div>
			</div>
			<div class="control-item">
				<button id="resistanceBtn">Resistance: On</button>
			</div>
		</div>

		<div class="control-group">
			<h3>Boundary Walls</h3>
			<div class="control-item">
				<button id="wallTopBtn">Top Wall: On</button>
				<button id="wallBottomBtn">Bottom Wall: On</button>
			</div>
			<div class="control-item">
				<button id="wallLeftBtn">Left Wall: On</button>
				<button id="wallRightBtn">Right Wall: On</button>
			</div>
		</div>

		<div class="control-group">
			<h3>Display Options</h3>
			<div class="control-item">
				<button id="velocityBtn">Show Velocity: Off</button>
			</div>
			<div class="control-item">
				<button id="massLabelBtn">Show Mass: On</button>
			</div>
		</div>
        
        <div id="update-board" class="control-group">
            <h3>Update Board (v4.0)</h3>
            
            <p>Recent Additions:</p>
            <ul>
                <li>**v4.0:** Added **Negative Gravity** support to the slider.</li>
                <li>**v4.0:** Added **Custom Gravity %** input field for precise control.</li>
                <li>**v3.0:** Corrected physics: Ball **mass now affects spring tension and gravity pull** ($a=F/m$).</li>
                <li>**v3.0:** Fixed boundary bugs for the top and right walls.</li>
                <li>**v2.0:** Added **Wall Toggles** (Top, Bottom, Left, Right) to the panel.</li>
            </ul>
        </div>
        </div>

	<canvas id="canvas"></canvas>
	<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const BASE_GRAVITY_UNIT = 0.5; // Represents 100% or 1G. 
let GRAVITY = BASE_GRAVITY_UNIT; // Current Gravity Multiplier
let gravityOn = true;
let showVelocity = false;
let FRICTION = 0.99;
let resistanceOn = true;
const RADIUS = 20; 
const SPRING_STRENGTH = 0.01; 
const SPRING_LENGTH = 100;

// Wall control state
let wallTopOn = true;
let wallBottomOn = true;
let wallLeftOn = true;
let wallRightOn = true;


let circles = [];
let springs = [];
let draggingBall = null;
let dragOffset = {x:0, y:0};
let dragHistory = []; 
let selectedBall = null;
let connectMode = false;
let selectedSpring = null;
let springEditor = null;
let deleteMode = false; 
let showMassLabel = true;
let paused = false;
let hoveredElement = null; 

// ====================================================================
// --- Utility Functions (Hover and Delete) ---
// ====================================================================

function getHoveredElement(x, y) {
	let foundBall = circles.find(c => Math.hypot(c.x-x, c.y-y) < c.radius);
	if (foundBall) return foundBall;

	let foundSpring = springs.find(s => {
		let ax = s.a.x, ay = s.a.y, bx = s.b.x, by = s.b.y;
		let dx = bx - ax, dy = by - ay;
		let t = ((x-ax)*dx + (y-ay)*dy) / (dx*dx + dy*dy);
		t = Math.max(0, Math.min(1, t));
		let px = ax + t*dx, py = ay + t*dy;
		return Math.hypot(px-x, py-y) < 10;
	});
	if (foundSpring) return foundSpring;

	return null;
}

function deleteElement(element) {
	if (element instanceof Circle) {
		springs = springs.filter(s => s.a !== element && s.b !== element);
		circles = circles.filter(c => c !== element);
		if (selectedBall === element) selectedBall = null;
		if (draggingBall === element) draggingBall = null;
	} else if (element instanceof Spring) {
		springs = springs.filter(s => s !== element);
		if (selectedSpring === element) selectedSpring = null;
	}
	if (window.ballEditor) window.ballEditor.remove();
	if (window.springEditor) window.springEditor.remove();
	if (hoveredElement === element) hoveredElement = null;
}


// ====================================================================
// --- Class Definitions ---
// ====================================================================

class Circle {
	constructor(x, y) {
		this.x = x;
		this.y = y;
		this.vx = 0;
		this.vy = 0;
		this.mass = 1; 
		this.isDragged = false;
		this.locked = false; 
		this.tx = x; 
		this.ty = y;
		this.color = '#4af'; 
		this.label = ''; 
	}
	get radius() {
		return RADIUS + (this.mass - 1) * 8;
	}
	draw() {
		ctx.beginPath();
		ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
		
		let fillStyle = (selectedBall === this) ? '#ff0' : (this.locked ? '#888' : this.color);
		
		if (hoveredElement === this) {
			ctx.shadowBlur = 15;
			ctx.shadowColor = 'red';
		}
		
		ctx.fillStyle = fillStyle;
		ctx.fill();
		ctx.shadowBlur = 0;
		ctx.strokeStyle = '#fff';
		ctx.lineWidth = 2;
		ctx.stroke();
		
		// 1. Draw Custom Label (Name)
		if (this.label) {
			ctx.font = '14px sans-serif';
			ctx.fillStyle = '#fff';
			ctx.textAlign = 'center';
			ctx.fillText(this.label, this.x, this.y - this.radius - (showMassLabel ? 25 : 10)); 
		}

		// 2. Draw Mass Label
		if (showMassLabel) {
			ctx.font = '12px sans-serif';
			ctx.fillStyle = '#fff';
			ctx.textAlign = 'center';
			ctx.fillText('m=' + this.mass.toFixed(2), this.x, this.y - this.radius - 10);
		}
		
		
		if (showVelocity) {
			let speed = Math.hypot(this.vx, this.vy);
			ctx.font = '14px sans-serif';
			ctx.fillStyle = '#0ff'; 
			ctx.textAlign = 'left';
			ctx.fillText('v=' + speed.toFixed(2), this.x + this.radius + 8, this.y + 5);
		}
	}
	update() {
		if (this.locked) {
			this.vx = 0;
			this.vy = 0;
			return;
		}

		if (this.isDragged) {
			this.vx = (this.x - this.tx); 
			this.vy = (this.y - this.ty);
			this.tx = this.x;
			this.ty = this.y;
			return;
		}

		this.tx = this.x;
		this.ty = this.y;
		
		// Gravity force applied, scaled by mass. Negative gravity works here too.
		if (gravityOn) {
			this.vy += GRAVITY * this.mass; 
		}

		
		if (resistanceOn) {
			this.vx *= FRICTION;
			this.vy *= FRICTION;
		}
		this.x += this.vx;
		this.y += this.vy;
		
		const restitution = 0.7;

		// --- Boundary Collision Logic ---
		
		// Left Wall
		if (wallLeftOn && this.x < this.radius) { 
			this.x = this.radius; 
			this.vx *= -restitution; 
		}
		// Right Wall
		if (wallRightOn && this.x > canvas.width - this.radius) { 
			this.x = canvas.width - this.radius; 
			this.vx *= -restitution; 
		}
		// Top Wall
		if (wallTopOn && this.y < this.radius) { 
			this.y = this.radius; 
			this.vy *= -restitution; 
		}
		// Bottom Wall
		if (wallBottomOn && this.y > canvas.height - this.radius) { 
			this.y = canvas.height - this.radius; 
			this.vy *= -restitution; 
		}
	}
}

class Spring {
	constructor(a, b) {
		this.a = a;
		this.b = b;
		this.length = SPRING_LENGTH;
		this.strength = SPRING_STRENGTH;
		this.selected = false;
	}
	draw() {
		ctx.beginPath();
		ctx.moveTo(this.a.x, this.a.y);
		ctx.lineTo(this.b.x, this.b.y);
		
		let strokeStyle = this.selected ? '#0f0' : '#fa4';
		let lineWidth = this.selected ? 5 : 3;
		
		if (hoveredElement === this) {
			strokeStyle = 'red';
			lineWidth = 5;
		}

		ctx.strokeStyle = strokeStyle;
		ctx.lineWidth = lineWidth;
		ctx.stroke();
	}
	update() {
		let dx = this.b.x - this.a.x;
		let dy = this.b.y - this.a.y;
		let dist = Math.hypot(dx, dy);
		let force = (dist - this.length) * this.strength; 
		let fx = (dx / dist) * force;
		let fy = (dy / dist) * force;
		
		// Divide the spring force by the ball's mass (F = ma, so a = F/m).
		if (!this.a.locked) {
			this.a.vx += fx / this.a.mass; 
			this.a.vy += fy / this.a.mass;
		}
		if (!this.b.locked) {
			this.b.vx -= fx / this.b.mass; 
			this.b.vy -= fy / this.b.mass;
		}
	}
}


// ====================================================================
// --- Core Simulation Loop ---
// ====================================================================

function draw() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	for (let spring of springs) spring.draw();
	for (let circle of circles) circle.draw();
	
	if (showVelocity) {
		for (let circle of circles) {
			let vx = circle.vx, vy = circle.vy;
			let speed = Math.hypot(vx, vy);
			if (speed > 0.5) {
				let arrowLen = Math.min(40, speed*8);
				let angle = Math.atan2(vy, vx);
				let x1 = circle.x, y1 = circle.y;
				let x2 = x1 + Math.cos(angle)*arrowLen;
				let y2 = y1 + Math.sin(angle)*arrowLen;
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.strokeStyle = '#0ff';
				ctx.lineWidth = 2;
				ctx.stroke();
			}
		}
	}

	if (connectMode && selectedBall) {
		ctx.beginPath();
		ctx.arc(selectedBall.x, selectedBall.y, selectedBall.radius+6, 0, Math.PI*2);
		ctx.strokeStyle = '#ff0';
		ctx.setLineDash([5,5]);
		ctx.stroke();
		ctx.setLineDash([]);
	}
}

function update() {
	if (paused) return;
	
	for (let spring of springs) spring.update();
	for (let circle of circles) circle.update();
	
	for (let i = 0; i < circles.length; i++) {
		for (let j = i+1; j < circles.length; j++) {
			let a = circles[i], b = circles[j];
			
			const aIsLocked = a.locked;
			const bIsLocked = b.locked;
			if (aIsLocked && bIsLocked) continue;

			let dx = b.x - a.x, dy = b.y - a.y;
			let dist = Math.hypot(dx, dy);
			let minDist = a.radius + b.radius;
			
			if (dist < minDist) {
				let angle = Math.atan2(dy, dx);
				let overlap = minDist - dist;
				
				if (aIsLocked) {
					b.x += Math.cos(angle) * overlap;
					b.y += Math.sin(angle) * overlap;
				} else if (bIsLocked) {
					a.x -= Math.cos(angle) * overlap;
					a.y -= Math.sin(angle) * overlap;
				} else {
					let totalMass = a.mass + b.mass;
					let ratioA = b.mass / totalMass;
					let ratioB = a.mass / totalMass;
					
					a.x -= Math.cos(angle) * overlap * ratioA;
					a.y -= Math.sin(angle) * overlap * ratioA;
					b.x += Math.cos(angle) * overlap * ratioB;
					b.y += Math.sin(angle) * overlap * ratioB;
				}
				
				let v1 = a.vx * Math.cos(angle) + a.vy * Math.sin(angle);
				let v2 = b.vx * Math.cos(angle) + b.vy * Math.sin(angle);
				
				let m1 = aIsLocked ? 99999999 : a.mass; 
				let m2 = bIsLocked ? 99999999 : b.mass;
				let totalMomentumMass = m1 + m2;
				
				let v1f = (v1 * (m1 - m2) + 2 * m2 * v2) / totalMomentumMass;
				let v2f = (v2 * (m2 - m1) + 2 * m1 * v1) / totalMomentumMass;
				
				let dv1 = v1f - v1;
				let dv2 = v2f - v2;
				
				if (!aIsLocked) {
					a.vx += dv1 * Math.cos(angle);
					a.vy += dv1 * Math.sin(angle);
					a.vx *= 0.95; a.vy *= 0.95;
				}
				if (!bIsLocked) {
					b.vx += dv2 * Math.cos(angle);
					b.vy += dv2 * Math.sin(angle);
					b.vx *= 0.95; b.vy *= 0.95;
				}
			}
		}
	}
}

function loop() {
	update();
	draw();
	requestAnimationFrame(loop);
}


// ====================================================================
// --- UI / Event Handlers ---
// ====================================================================

const controlsPanel = document.getElementById('controls-panel');
const toggleBtn = document.getElementById('toggle-btn');
toggleBtn.addEventListener('click', () => {
	controlsPanel.classList.toggle('visible');
	toggleBtn.textContent = controlsPanel.classList.contains('visible') ? 'Controls ◀' : 'Controls ▶';
});

// Wall Toggle Handler Factory
function createWallToggle(wallVarName, buttonId) {
	const btn = document.getElementById(buttonId);
	
	btn.onclick = function() {
		// Toggle the corresponding global variable
		eval(`${wallVarName} = !${wallVarName};`);
		// Update button text and style
		this.textContent = `${buttonId.replace('wall', '').replace('Btn', ' Wall')}: ${eval(wallVarName) ? 'On' : 'Off'}`;
		this.style.background = eval(wallVarName) ? '' : '#888';
	};
}

createWallToggle('wallTopOn', 'wallTopBtn');
createWallToggle('wallBottomOn', 'wallBottomBtn');
createWallToggle('wallLeftOn', 'wallLeftBtn');
createWallToggle('wallRightOn', 'wallRightBtn');

// Gravity Input Logic
const gravitySlider = document.getElementById('gravitySlider');
const gravityValueSpan = document.getElementById('gravityValue');
const gravityCustomInput = document.getElementById('gravityCustomInput');
const applyGravityBtn = document.getElementById('applyGravityBtn');

// Function to sync all gravity controls
function updateGravity(newGravityValue) {
    // Round to 2 decimal places for display consistency
    GRAVITY = Math.round(newGravityValue * 100) / 100;
    
    // Update Slider
    gravitySlider.value = GRAVITY;
    
    // Update Value Span (xG)
    gravityValueSpan.textContent = GRAVITY.toFixed(2);
    
    // Update Custom Input (Percentage)
    const percentage = Math.round((GRAVITY / BASE_GRAVITY_UNIT) * 100);
    gravityCustomInput.value = percentage;
}

// 1. Slider input event (instant update)
gravitySlider.oninput = function() {
    updateGravity(parseFloat(this.value));
};

// 2. Custom Input button click event
applyGravityBtn.onclick = function() {
    let percentage = parseFloat(gravityCustomInput.value);
    
    // Clamp the percentage input to a reasonable range 
    if (isNaN(percentage)) percentage = 0;
    percentage = Math.max(-200, Math.min(200, percentage));
    
    // Calculate new GRAVITY value
    const newGravity = BASE_GRAVITY_UNIT * (percentage / 100);
    
    updateGravity(newGravity);
};

// 3. Custom Input 'Enter' key press (for convenience)
gravityCustomInput.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        applyGravityBtn.click();
    }
});


// Clear All button
document.getElementById('clearAllBtn').onclick = function() {
	circles = [];
	springs = [];
	draggingBall = null;
	selectedBall = null;
	connectMode = false;
	selectedSpring = null;
	if (window.ballEditor) window.ballEditor.remove();
	if (window.springEditor) window.springEditor.remove();
	hoveredElement = null;
};

// Other Button logic
document.getElementById('gravityBtn').onclick = function() {
	gravityOn = !gravityOn;
	this.textContent = 'Gravity: ' + (gravityOn ? 'On' : 'Off');
	this.style.background = gravityOn ? '' : '#888';
};
document.getElementById('velocityBtn').onclick = function() {
	showVelocity = !showVelocity;
	this.textContent = 'Show Velocity: ' + (showVelocity ? 'On' : 'Off');
	this.style.background = showVelocity ? '#0ff' : '';
};
document.getElementById('pauseBtn').onclick = function() {
	paused = !paused;
	this.textContent = 'Pause: ' + (paused ? 'On' : 'Off');
	this.style.background = paused ? '#c00' : '';
};
document.getElementById('deleteModeBtn').onclick = function() {
	deleteMode = !deleteMode;
	this.textContent = 'Single-Click Delete: ' + (deleteMode ? 'On' : 'Off');
	this.style.background = deleteMode ? '#c00' : '';
};
document.getElementById('massLabelBtn').onclick = function() {
	showMassLabel = !showMassLabel;
	this.textContent = 'Show Mass: ' + (showMassLabel ? 'On' : 'Off');
	this.style.background = showMassLabel ? '' : '#888';
};
document.getElementById('resistanceBtn').onclick = function() {
	resistanceOn = !resistanceOn;
	this.textContent = 'Resistance: ' + (resistanceOn ? 'On' : 'Off');
	this.style.background = resistanceOn ? '' : '#888';
	FRICTION = resistanceOn ? 0.99 : 1.0;
};


// Ball property editor
function showBallEditor(ball) {
	if (window.ballEditor) window.ballEditor.remove();
	let editor = document.createElement('div');
	window.ballEditor = editor;
	editor.className = 'ball-editor-panel';
	editor.style.position = 'absolute';
	editor.style.background = '#333';
	editor.style.color = '#fff';
	editor.style.padding = '12px';
	editor.style.borderRadius = '8px';
	editor.style.zIndex = 10;
	editor.innerHTML = `<b>Edit Ball</b><br>
		<label>Name:</label> <input type='text' id='ballLabel' value='${ball.label}'><br>
		<label>Mass:</label> <input type='number' id='ballMass' value='${ball.mass.toFixed(2)}' step='0.1' min='0.1' max='10'><br>
		<label>Color:</label> <input type='color' id='ballColor' value='${ball.color}'><br>
		<label><input type='checkbox' id='ballLock' ${ball.locked ? 'checked' : ''}> Lock Ball</label><br>
		<button id='ballClose'>Close</button>
	`;
	document.body.appendChild(editor);
	
	function updatePanelPosition() {
		editor.style.left = (ball.x - 20) + 'px';
		editor.style.top = (ball.y - ball.radius - 120) + 'px'; 
	}
	updatePanelPosition();
	
	function followBall() {
		if (window.ballEditor === editor) {
			updatePanelPosition();
			requestAnimationFrame(followBall);
		}
	}
	followBall();
	
	// --- Instant Update Logic ---
	const massInput = document.getElementById('ballMass');
	const colorInput = document.getElementById('ballColor');
	const labelInput = document.getElementById('ballLabel');
	const lockInput = document.getElementById('ballLock');

	massInput.oninput = () => {
		ball.mass = Math.max(0.1, parseFloat(massInput.value));
	};
	colorInput.oninput = () => {
		ball.color = colorInput.value;
	};
	labelInput.oninput = () => {
		ball.label = labelInput.value;
	};
	lockInput.oninput = () => {
		ball.locked = lockInput.checked;
	};
	
	document.getElementById('ballClose').onclick = () => {
		editor.remove();
		window.ballEditor = null;
	};
}

// Spring property editor (unchanged)
function showSpringEditor(spring) {
	if (window.springEditor) window.springEditor.remove();
	springEditor = document.createElement('div');
	window.springEditor = springEditor;
	springEditor.style.position = 'absolute';
	springEditor.style.left = '50px';
	springEditor.style.top = '50px';
	springEditor.style.background = '#333';
	springEditor.style.color = '#fff';
	springEditor.style.padding = '16px';
	springEditor.style.borderRadius = '8px';
	springEditor.style.zIndex = 10;
	springEditor.innerHTML = `<b>Edit Spring</b><br>
		Length: <input type='number' id='springLength' value='${spring.length}' step='1' min='10' max='1000'><br>
		Strength: <input type='number' id='springStrength' value='${spring.strength}' step='0.001' min='0.001' max='1'><br>
		<button id='springSave'>Save</button>
		<button id='springClose'>Close</button>
	`;
	document.body.appendChild(springEditor);
	document.getElementById('springSave').onclick = () => {
		spring.length = parseFloat(document.getElementById('springLength').value);
		spring.strength = parseFloat(document.getElementById('springStrength').value);
		spring.selected = false;
		selectedSpring = null;
		springEditor.remove();
		window.springEditor = null;
	};
	document.getElementById('springClose').onclick = () => {
		spring.selected = false;
		selectedSpring = null;
		springEditor.remove();
		window.springEditor = null;
	};
}


// Canvas Mouse Events
canvas.addEventListener('mousedown', e => {
	dragHistory = [];
	let x = e.clientX, y = e.clientY;
	
	let found = getHoveredElement(x, y);

	if (deleteMode && found) {
		deleteElement(found);
		return;
	}

	if (found instanceof Spring) {
		springs.forEach(s => s.selected = false);
		found.selected = true;
		selectedSpring = found;
		showSpringEditor(found);
		return;
	}
	
	if (found instanceof Circle) {
		if (connectMode) {
			if (selectedBall && found !== selectedBall) {
				if (!springs.some(s => (s.a === selectedBall && s.b === found) || (s.a === found && s.b === selectedBall))) {
					springs.push(new Spring(selectedBall, found));
				}
				connectMode = false;
				selectedBall = null;
				return;
			}
			return;
		}
		
		if (e.button === 2) {
			showBallEditor(found);
			return;
		}
		
		draggingBall = found;
		dragOffset.x = x - found.x;
		dragOffset.y = y - found.y;
		found.isDragged = true;
		found.tx = found.x; 
		found.ty = found.y;
		selectedBall = found;
		if (window.ballEditor) window.ballEditor.remove(); 
	} else {
		circles.push(new Circle(x, y));
		selectedBall = null;
		connectMode = false;
		if (window.ballEditor) window.ballEditor.remove();
	}
});

canvas.addEventListener('contextmenu', e => {
	e.preventDefault();
});

canvas.addEventListener('mousemove', e => {
	let x = e.clientX, y = e.clientY;
	hoveredElement = getHoveredElement(x, y);

	if (draggingBall) {
		let newX = x - dragOffset.x;
		let newY = y - dragOffset.y;
		
		dragHistory.push({x: newX, y: newY, t: performance.now()});
		if (dragHistory.length > 10) dragHistory.shift();

		draggingBall.x = newX;
		draggingBall.y = newY;
	}
});

canvas.addEventListener('mouseup', e => {
	if (draggingBall) {
		if (dragHistory.length >= 2) {
			let last = dragHistory[dragHistory.length-1];
			let first = dragHistory[0];
			let dt = (last.t - first.t) / 1000; 
			if (dt > 0) {
				let dx = last.x - first.x;
				let dy = last.y - first.y;
				const flickFactor = 0.05; 
				draggingBall.vx = dx / dt * flickFactor; 
				draggingBall.vy = dy / dt * flickFactor;
			}
		}
		draggingBall.isDragged = false;
		draggingBall = null;
		dragHistory = [];
	}
});

canvas.addEventListener('dblclick', e => {
	let x = e.clientX, y = e.clientY;
	let found = circles.find(c => Math.hypot(c.x-x, c.y-y) < c.radius);
	if (found) {
		selectedBall = found;
		connectMode = true;
	}
});

document.addEventListener('keydown', e => {
	if ((e.key === 'd' || e.key === 'D') && 
		document.activeElement.tagName !== 'INPUT' && 
		document.activeElement.tagName !== 'TEXTAREA') 
	{
		if (hoveredElement) {
			e.preventDefault(); 
			deleteElement(hoveredElement);
		}
	}
});


window.addEventListener('resize', () => {
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
});

loop();
</script>
</body>
</html>
