<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Physics Circles Playground</title>
	<style>
		body { margin: 0; overflow: hidden; }
		canvas { background: #222; display: block; }
		#controls-panel {
			position: absolute;
			top: 0;
			right: 0;
			width: 280px;
			height: 100vh;
			background: rgba(34, 34, 34, 0.9);
			color: #fff;
			font-family: sans-serif;
			padding: 20px;
			box-sizing: border-box;
			transform: translateX(100%);
			transition: transform 0.3s ease-in-out;
			overflow-y: auto;
			z-index: 100;
		}
		#controls-panel.visible {
			transform: translateX(0);
		}
		#toggle-btn {
			position: absolute;
			top: 10px;
			right: 10px;
			background: #333;
			color: #fff;
			border: none;
			border-radius: 4px;
			padding: 8px 12px;
			cursor: pointer;
			z-index: 101;
			font-size: 16px;
		}
		.control-group {
			margin-bottom: 20px;
		}
		.control-group h3 {
			margin-top: 0;
			border-bottom: 1px solid #555;
			padding-bottom: 5px;
		}
		.control-item {
			margin-bottom: 10px;
		}
		.control-item label {
			display: block;
			margin-bottom: 5px;
		}
		button {
			padding: 5px 10px;
			margin: 2px;
			border: none;
			border-radius: 4px;
			cursor: pointer;
		}
		input[type="range"] {
			vertical-align: middle;
			width: 150px;
		}
		/* For the info text */
		#info-text {
			position: absolute;
			top: 10px;
			left: 10px;
			color: #fff;
			font-family: sans-serif;
			user-select: none;
		}
	</style>
</head>
<body>
	<div id="info-text">
		**Physics Circles Playground**<br>
		Click to add circles.<br>
		Right-click a ball to edit its mass and lock state.<br>
		Drag balls to move.<br>
		Double-click a ball, then click another to connect.<br>
		Hover over an element and press 'D' to delete it.
	</div>
	<button id="toggle-btn">Controls â–¶</button>
	
	<div id="controls-panel">
		<div class="control-group">
			<h3>Simulation Controls</h3>
			<div class="control-item">
				<button id="pauseBtn">Pause: Off</button>
			</div>
			<div class="control-item">
				<button id="deleteModeBtn">Single-Click Delete: Off</button>
			</div>
		</div>

		<div class="control-group">
			<h3>Global Physics</h3>
			<div class="control-item">
				<button id="gravityBtn">Gravity: On</button>
				<div>
					Gravity Strength: <input type="range" id="gravitySlider" min="0" max="2" step="0.01" value="0.5">
					<span id="gravityValue">0.50</span>
				</div>
			</div>
			<div class="control-item">
				<button id="resistanceBtn">Resistance: On</button>
			</div>
		</div>

		<div class="control-group">
			<h3>Display Options</h3>
			<div class="control-item">
				<button id="velocityBtn">Show Velocity: Off</button>
			</div>
			<div class="control-item">
				<button id="massLabelBtn">Show Mass: On</button>
			</div>
		</div>
	</div>

	<canvas id="canvas"></canvas>
	<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let GRAVITY = 0.5; 
let gravityOn = true;
let showVelocity = false;
let FRICTION = 0.99;
let resistanceOn = true;
const RADIUS = 20; 
const SPRING_STRENGTH = 0.01;
const SPRING_LENGTH = 100;

let circles = [];
let springs = [];
let draggingBall = null;
let dragOffset = {x:0, y:0};
let dragHistory = []; 
let selectedBall = null;
let connectMode = false;
let selectedSpring = null;
let springEditor = null;
let deleteMode = false; 
let showMassLabel = true;
let paused = false;
let hoveredElement = null; 

// ====================================================================
// --- Utility Functions (Hover and Delete) ---
// ====================================================================

function getHoveredElement(x, y) {
	let foundBall = circles.find(c => Math.hypot(c.x-x, c.y-y) < c.radius);
	if (foundBall) return foundBall;

	let foundSpring = springs.find(s => {
		let ax = s.a.x, ay = s.a.y, bx = s.b.x, by = s.b.y;
		let dx = bx - ax, dy = by - ay;
		let t = ((x-ax)*dx + (y-ay)*dy) / (dx*dx + dy*dy);
		t = Math.max(0, Math.min(1, t));
		let px = ax + t*dx, py = ay + t*dy;
		return Math.hypot(px-x, py-y) < 10;
	});
	if (foundSpring) return foundSpring;

	return null;
}

function deleteElement(element) {
	if (element instanceof Circle) {
		springs = springs.filter(s => s.a !== element && s.b !== element);
		circles = circles.filter(c => c !== element);
		if (selectedBall === element) selectedBall = null;
		if (draggingBall === element) draggingBall = null;
	} else if (element instanceof Spring) {
		springs = springs.filter(s => s !== element);
		if (selectedSpring === element) selectedSpring = null;
	}
	if (window.ballEditor) window.ballEditor.remove();
	if (window.springEditor) window.springEditor.remove();
	if (hoveredElement === element) hoveredElement = null;
}


// ====================================================================
// --- Class Definitions ---
// ====================================================================

class Circle {
	constructor(x, y) {
		this.x = x;
		this.y = y;
		this.vx = 0;
		this.vy = 0;
		this.mass = 1; 
		this.isDragged = false;
		this.locked = false; 
		this.tx = x; 
		this.ty = y;
	}
	get radius() {
		return RADIUS + (this.mass - 1) * 8;
	}
	draw() {
		ctx.beginPath();
		ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
		let fillStyle = (selectedBall === this) ? '#ff0' : (this.locked ? '#888' : '#4af');
		
		if (hoveredElement === this) {
			ctx.shadowBlur = 15;
			ctx.shadowColor = 'red';
		}
		
		ctx.fillStyle = fillStyle;
		ctx.fill();
		ctx.shadowBlur = 0;
		ctx.strokeStyle = '#fff';
		ctx.lineWidth = 2;
		ctx.stroke();
		
		if (showMassLabel) {
			ctx.font = '12px sans-serif';
			ctx.fillStyle = '#fff';
			ctx.textAlign = 'center';
			ctx.fillText('m=' + this.mass.toFixed(2), this.x, this.y - this.radius - 10);
		}
		
		if (showVelocity) {
			let speed = Math.hypot(this.vx, this.vy);
			ctx.font = '14px sans-serif';
			ctx.fillStyle = '#0ff'; 
			ctx.textAlign = 'left';
			ctx.fillText('v=' + speed.toFixed(2), this.x + this.radius + 8, this.y + 5);
		}
	}
	update() {
		if (this.locked) {
			this.vx = 0;
			this.vy = 0;
			return;
		}

		if (this.isDragged) {
			this.vx = (this.x - this.tx); 
			this.vy = (this.y - this.ty);
			this.tx = this.x;
			this.ty = this.y;
			return;
		}

		this.tx = this.x;
		this.ty = this.y;
		
		if (gravityOn) this.vy += GRAVITY; 
		
		if (resistanceOn) {
			this.vx *= FRICTION;
			this.vy *= FRICTION;
		}
		this.x += this.vx;
		this.y += this.vy;
		
		const restitution = 0.7;
		if (this.x < this.radius) { this.x = this.radius; this.vx *= -restitution; }
		if (this.x > canvas.width - this.radius) { this.x = canvas.width - this.radius; this.vx *= -restitution; }
		if (this.y < this.radius) { this.y = this.radius; this.vy *= -restitution; }
		if (this.y > canvas.height - this.radius) { this.y = canvas.height - this.radius; this.vy *= -restitution; }
	}
}

class Spring {
	constructor(a, b) {
		this.a = a;
		this.b = b;
		this.length = SPRING_LENGTH;
		this.strength = SPRING_STRENGTH;
		this.selected = false;
	}
	draw() {
		ctx.beginPath();
		ctx.moveTo(this.a.x, this.a.y);
		ctx.lineTo(this.b.x, this.b.y);
		
		let strokeStyle = this.selected ? '#0f0' : '#fa4';
		let lineWidth = this.selected ? 5 : 3;
		
		if (hoveredElement === this) {
			strokeStyle = 'red';
			lineWidth = 5;
		}

		ctx.strokeStyle = strokeStyle;
		ctx.lineWidth = lineWidth;
		ctx.stroke();
	}
	update() {
		let dx = this.b.x - this.a.x;
		let dy = this.b.y - this.a.y;
		let dist = Math.hypot(dx, dy);
		let force = (dist - this.length) * this.strength; 
		let fx = (dx / dist) * force;
		let fy = (dy / dist) * force;
		
		if (!this.a.locked) {
			this.a.vx += fx / this.a.mass;
			this.a.vy += fy / this.a.mass;
		}
		if (!this.b.locked) {
			this.b.vx -= fx / this.b.mass;
			this.b.vy -= fy / this.b.mass;
		}
	}
}


// ====================================================================
// --- Core Simulation Loop ---
// ====================================================================

function draw() {
	ctx.clearRect(0, 0, canvas.width, canvas.height);
	for (let spring of springs) spring.draw();
	for (let circle of circles) circle.draw();
	
	if (showVelocity) {
		for (let circle of circles) {
			let vx = circle.vx, vy = circle.vy;
			let speed = Math.hypot(vx, vy);
			if (speed > 0.5) {
				let arrowLen = Math.min(40, speed*8);
				let angle = Math.atan2(vy, vx);
				let x1 = circle.x, y1 = circle.y;
				let x2 = x1 + Math.cos(angle)*arrowLen;
				let y2 = y1 + Math.sin(angle)*arrowLen;
				ctx.beginPath();
				ctx.moveTo(x1, y1);
				ctx.lineTo(x2, y2);
				ctx.strokeStyle = '#0ff';
				ctx.lineWidth = 2;
				ctx.stroke();
			}
		}
	}

	if (connectMode && selectedBall) {
		ctx.beginPath();
		ctx.arc(selectedBall.x, selectedBall.y, selectedBall.radius+6, 0, Math.PI*2);
		ctx.strokeStyle = '#ff0';
		ctx.setLineDash([5,5]);
		ctx.stroke();
		ctx.setLineDash([]);
	}
}

function update() {
	if (paused) return;
	
	for (let spring of springs) spring.update();
	for (let circle of circles) circle.update();
	
	for (let i = 0; i < circles.length; i++) {
		for (let j = i+1; j < circles.length; j++) {
			let a = circles[i], b = circles[j];
			
			const aIsLocked = a.locked;
			const bIsLocked = b.locked;
			if (aIsLocked && bIsLocked) continue;

			let dx = b.x - a.x, dy = b.y - a.y;
			let dist = Math.hypot(dx, dy);
			let minDist = a.radius + b.radius;
			
			if (dist < minDist) {
				let angle = Math.atan2(dy, dx);
				let overlap = minDist - dist;
				
				if (aIsLocked) {
					b.x += Math.cos(angle) * overlap;
					b.y += Math.sin(angle) * overlap;
				} else if (bIsLocked) {
					a.x -= Math.cos(angle) * overlap;
					a.y -= Math.sin(angle) * overlap;
				} else {
					let totalMass = a.mass + b.mass;
					let ratioA = b.mass / totalMass;
					let ratioB = a.mass / totalMass;
					
					a.x -= Math.cos(angle) * overlap * ratioA;
					a.y -= Math.sin(angle) * overlap * ratioA;
					b.x += Math.cos(angle) * overlap * ratioB;
					b.y += Math.sin(angle) * overlap * ratioB;
				}
				
				let v1 = a.vx * Math.cos(angle) + a.vy * Math.sin(angle);
				let v2 = b.vx * Math.cos(angle) + b.vy * Math.sin(angle);
				
				let m1 = aIsLocked ? 99999999 : a.mass; 
				let m2 = bIsLocked ? 99999999 : b.mass;
				let totalMomentumMass = m1 + m2;
				
				let v1f = (v1 * (m1 - m2) + 2 * m2 * v2) / totalMomentumMass;
				let v2f = (v2 * (m2 - m1) + 2 * m1 * v1) / totalMomentumMass;
				
				let dv1 = v1f - v1;
				let dv2 = v2f - v2;
				
				if (!aIsLocked) {
					a.vx += dv1 * Math.cos(angle);
					a.vy += dv1 * Math.sin(angle);
					a.vx *= 0.95; a.vy *= 0.95;
				}
				if (!bIsLocked) {
					b.vx += dv2 * Math.cos(angle);
					b.vy += dv2 * Math.sin(angle);
					b.vx *= 0.95; b.vy *= 0.95;
				}
			}
		}
	}
}

function loop() {
	update();
	draw();
	requestAnimationFrame(loop);
}


// ====================================================================
// --- UI / Event Handlers ---
// ====================================================================

const controlsPanel = document.getElementById('controls-panel');
const toggleBtn = document.getElementById('toggle-btn');
toggleBtn.addEventListener('click', () => {
	controlsPanel.classList.toggle('visible');
	toggleBtn.textContent = controlsPanel.classList.contains('visible') ? 'Controls â—€' : 'Controls â–¶';
});

// Button logic
document.getElementById('gravitySlider').oninput = function() {
	GRAVITY = parseFloat(this.value);
	document.getElementById('gravityValue').textContent = GRAVITY.toFixed(2);
};
document.getElementById('gravityBtn').onclick = function() {
	gravityOn = !gravityOn;
	this.textContent = 'Gravity: ' + (gravityOn ? 'On' : 'Off');
	this.style.background = gravityOn ? '' : '#888';
};
document.getElementById('velocityBtn').onclick = function() {
	showVelocity = !showVelocity;
	this.textContent = 'Show Velocity: ' + (showVelocity ? 'On' : 'Off');
	this.style.background = showVelocity ? '#0ff' : '';
};
document.getElementById('pauseBtn').onclick = function() {
	paused = !paused;
	this.textContent = 'Pause: ' + (paused ? 'On' : 'Off');
	this.style.background = paused ? '#c00' : '';
};
document.getElementById('deleteModeBtn').onclick = function() {
	deleteMode = !deleteMode;
	this.textContent = 'Single-Click Delete: ' + (deleteMode ? 'On' : 'Off');
	this.style.background = deleteMode ? '#c00' : '';
};
document.getElementById('massLabelBtn').onclick = function() {
	showMassLabel = !showMassLabel;
	this.textContent = 'Show Mass: ' + (showMassLabel ? 'On' : 'Off');
	this.style.background = showMassLabel ? '' : '#888';
};
document.getElementById('resistanceBtn').onclick = function() {
	resistanceOn = !resistanceOn;
	this.textContent = 'Resistance: ' + (resistanceOn ? 'On' : 'Off');
	this.style.background = resistanceOn ? '' : '#888';
	FRICTION = resistanceOn ? 0.99 : 1.0;
};


// Ball property editor
function showBallEditor(ball) {
	if (window.ballEditor) window.ballEditor.remove();
	let editor = document.createElement('div');
	window.ballEditor = editor;
	editor.style.position = 'absolute';
	editor.style.background = '#333';
	editor.style.color = '#fff';
	editor.style.padding = '12px';
	editor.style.borderRadius = '8px';
	editor.style.zIndex = 10;
	editor.innerHTML = `<b>Edit Ball</b><br>
		Mass: <input type='number' id='ballMass' value='${ball.mass.toFixed(2)}' step='0.1' min='0.1' max='10'><br>
		<label><input type='checkbox' id='ballLock' ${ball.locked ? 'checked' : ''}> Lock Ball</label><br>
		<button id='ballSave'>Save</button>
		<button id='ballClose'>Close</button>
	`;
	document.body.appendChild(editor);
	
	function updatePanelPosition() {
		editor.style.left = (ball.x - 20) + 'px';
		editor.style.top = (ball.y - ball.radius - 80) + 'px';
	}
	updatePanelPosition();
	
	function followBall() {
		if (window.ballEditor === editor) {
			updatePanelPosition();
			requestAnimationFrame(followBall);
		}
	}
	followBall();
	
	document.getElementById('ballSave').onclick = () => {
		ball.mass = Math.max(0.1, parseFloat(document.getElementById('ballMass').value));
		ball.locked = document.getElementById('ballLock').checked;
		editor.remove();
		window.ballEditor = null;
	};
	document.getElementById('ballClose').onclick = () => {
		editor.remove();
		window.ballEditor = null;
	};
}

// Spring property editor
function showSpringEditor(spring) {
	if (window.springEditor) window.springEditor.remove();
	springEditor = document.createElement('div');
	window.springEditor = springEditor;
	springEditor.style.position = 'absolute';
	springEditor.style.left = '50px';
	springEditor.style.top = '50px';
	springEditor.style.background = '#333';
	springEditor.style.color = '#fff';
	springEditor.style.padding = '16px';
	springEditor.style.borderRadius = '8px';
	springEditor.style.zIndex = 10;
	springEditor.innerHTML = `<b>Edit Spring</b><br>
		Length: <input type='number' id='springLength' value='${spring.length}' step='1' min='10' max='1000'><br>
		Strength: <input type='number' id='springStrength' value='${spring.strength}' step='0.001' min='0.001' max='1'><br>
		<button id='springSave'>Save</button>
		<button id='springClose'>Close</button>
	`;
	document.body.appendChild(springEditor);
	document.getElementById('springSave').onclick = () => {
		spring.length = parseFloat(document.getElementById('springLength').value);
		spring.strength = parseFloat(document.getElementById('springStrength').value);
		spring.selected = false;
		selectedSpring = null;
		springEditor.remove();
		window.springEditor = null;
	};
	document.getElementById('springClose').onclick = () => {
		spring.selected = false;
		selectedSpring = null;
		springEditor.remove();
		window.springEditor = null;
	};
}


// Canvas Mouse Events
canvas.addEventListener('mousedown', e => {
	dragHistory = [];
	let x = e.clientX, y = e.clientY;
	
	let found = getHoveredElement(x, y);

	if (deleteMode && found) {
		deleteElement(found);
		return;
	}

	if (found instanceof Spring) {
		springs.forEach(s => s.selected = false);
		found.selected = true;
		selectedSpring = found;
		showSpringEditor(found);
		return;
	}
	
	if (found instanceof Circle) {
		if (connectMode) {
			if (selectedBall && found !== selectedBall) {
				if (!springs.some(s => (s.a === selectedBall && s.b === found) || (s.a === found && s.b === selectedBall))) {
					springs.push(new Spring(selectedBall, found));
				}
				connectMode = false;
				selectedBall = null;
				return;
			}
			return;
		}
		
		if (e.button === 2) {
			showBallEditor(found);
			return;
		}
		
		draggingBall = found;
		dragOffset.x = x - found.x;
		dragOffset.y = y - found.y;
		found.isDragged = true;
		found.tx = found.x; 
		found.ty = found.y;
		selectedBall = found;
		if (window.ballEditor) window.ballEditor.remove(); 
	} else {
		circles.push(new Circle(x, y));
		selectedBall = null;
		connectMode = false;
		if (window.ballEditor) window.ballEditor.remove();
	}
});

canvas.addEventListener('contextmenu', e => {
	e.preventDefault();
});

canvas.addEventListener('mousemove', e => {
	let x = e.clientX, y = e.clientY;
	hoveredElement = getHoveredElement(x, y);

	if (draggingBall) {
		let newX = x - dragOffset.x;
		let newY = y - dragOffset.y;
		
		dragHistory.push({x: newX, y: newY, t: performance.now()});
		if (dragHistory.length > 10) dragHistory.shift();

		draggingBall.x = newX;
		draggingBall.y = newY;
	}
});

canvas.addEventListener('mouseup', e => {
	if (draggingBall) {
		if (dragHistory.length >= 2) {
			let last = dragHistory[dragHistory.length-1];
			let first = dragHistory[0];
			let dt = (last.t - first.t) / 1000; 
			if (dt > 0) {
				let dx = last.x - first.x;
				let dy = last.y - first.y;
				const flickFactor = 0.05; 
				draggingBall.vx = dx / dt * flickFactor; 
				draggingBall.vy = dy / dt * flickFactor;
			}
		}
		draggingBall.isDragged = false;
		draggingBall = null;
		dragHistory = [];
	}
});

canvas.addEventListener('dblclick', e => {
	let x = e.clientX, y = e.clientY;
	let found = circles.find(c => Math.hypot(c.x-x, c.y-y) < c.radius);
	if (found) {
		selectedBall = found;
		connectMode = true;
	}
});

document.addEventListener('keydown', e => {
	if ((e.key === 'd' || e.key === 'D') && 
		document.activeElement.tagName !== 'INPUT' && 
		document.activeElement.tagName !== 'TEXTAREA') 
	{
		if (hoveredElement) {
			e.preventDefault(); 
			deleteElement(hoveredElement);
		}
	}
});


window.addEventListener('resize', () => {
	canvas.width = window.innerWidth;
	canvas.height = window.innerHeight;
});

loop();
</script>
</body>
</html>
